<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âditeur AR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }

        /* HEADER */
        .header {
            height: 60px;
            background: #2d2d2d;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 2px solid #4CAF50;
        }

        .header h1 {
            font-size: 24px;
            color: #4CAF50;
        }

        .header-actions {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-secondary {
            background: #666;
            color: white;
        }

        .btn-secondary:hover {
            background: #777;
        }

        .btn:disabled {
            background: #444;
            color: #666;
            cursor: not-allowed;
        }

        /* LAYOUT PRINCIPAL */
        .main-layout {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* SIDEBAR PROJETS */
        .sidebar {
            width: 300px;
            background: #2d2d2d;
            border-right: 1px solid #555;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #555;
        }

        .sidebar-header h3 {
            margin-bottom: 15px;
            color: #4CAF50;
        }

        .projects-list {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
        }

        .project-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #3d3d3d;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 3px solid transparent;
            position: relative;
        }

        .project-item:hover {
            background: #4d4d4d;
        }

        .project-item.active {
            border-left: 3px solid #4CAF50;
            background: #4d4d4d;
        }

        .project-item h4 {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .project-item p {
            font-size: 12px;
            color: #aaa;
        }

        .project-delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #f44336;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .project-item:hover .project-delete-btn {
            display: flex;
        }

        .project-delete-btn:hover {
            background: #da190b;
        }

        /* ZONE CENTRALE */
        .center-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* TOOLBAR */
        .toolbar {
            height: 50px;
            background: #333;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            border-bottom: 1px solid #555;
        }

        .toolbar-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toolbar-label {
            font-size: 12px;
            color: #aaa;
            margin-right: 5px;
        }

        /* VIEWPORT 3D */
        .viewport {
            flex: 1;
            position: relative;
            background: #1a1a1a;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .drop-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 200px;
            border: 2px dashed #4CAF50;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #4CAF50;
            font-size: 16px;
            text-align: center;
            transition: all 0.3s;
            pointer-events: none;
            opacity: 0.7;
        }

        .drop-zone.active {
            background: rgba(76, 175, 80, 0.1);
            border-color: #66BB6A;
            opacity: 1;
        }

        .drop-zone.hidden {
            display: none;
        }

        /* PANNEAU PROPRI√âT√âS */
        .properties-panel {
            width: 280px;
            background: #2d2d2d;
            border-left: 1px solid #555;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ONGLETS */
        .panel-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #555;
        }

        .panel-tab {
            flex: 1;
            padding: 10px;
            background: #333;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
            border-right: 1px solid #555;
        }

        .panel-tab:last-child {
            border-right: none;
        }

        .panel-tab.active {
            background: #2d2d2d;
            color: #4CAF50;
        }

        .panel-tab:hover:not(.active) {
            background: #3d3d3d;
            color: #ccc;
        }

        /* CONTENU DES ONGLETS */
        .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .panel-content h3 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 16px;
        }

        /* LISTE DES OBJETS */
        .objects-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .object-item {
            padding: 10px;
            background: #3d3d3d;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 3px solid transparent;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .object-item:hover {
            background: #4d4d4d;
        }

        .object-item.selected {
            border-left: 3px solid #4CAF50;
            background: #4d4d4d;
        }

        .object-info {
            flex: 1;
        }

        .object-name {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .object-type {
            font-size: 11px;
            color: #aaa;
        }

        .object-actions {
            display: flex;
            gap: 5px;
        }

        .object-rename-btn {
            background: #666;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .object-rename-btn:hover {
            background: #777;
        }

        .object-delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .object-delete-btn:hover {
            background: #da190b;
        }

        /* MODAL */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 8px;
            width: 400px;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #4CAF50;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 4px;
            color: white;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .hidden {
            display: none !important;
        }

        /* STATUS BAR */
        .status-bar {
            height: 25px;
            background: #1a1a1a;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 12px;
            color: #aaa;
            border-top: 1px solid #555;
        }

        .status-item {
            margin-right: 20px;
        }

        /* PROPRI√âT√âS */
        .property-group {
            margin-bottom: 25px;
        }

        .property-group h4 {
            margin-bottom: 10px;
            font-size: 14px;
            color: #ccc;
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .property-label {
            width: 20px;
            font-size: 12px;
            color: #aaa;
        }

        .property-input {
            flex: 1;
            padding: 4px 8px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 3px;
            color: white;
            font-size: 12px;
        }

        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
        }

        .delete-btn:hover {
            background: #da190b;
        }
    </style>
</head>
<body>
    <!-- HEADER -->
    <div class="header">
        <h1>üå± √âditeur AR</h1>
        <div class="header-actions">
            <button class="btn btn-primary" onclick="exportProjectZIP()">üì¶ T√©l√©charger ZIP</button>
            <button class="btn btn-secondary" onclick="exportProject()">üìÑ Export JSON</button>
            <button class="btn btn-secondary" onclick="previewAR()">üëÅÔ∏è Aper√ßu AR</button>
        </div>
    </div>

    <!-- LAYOUT PRINCIPAL -->
    <div class="main-layout">
        <!-- SIDEBAR PROJETS -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>Projets</h3>
                <button class="btn btn-primary" style="width: 100%; margin-bottom: 10px;" onclick="showNewProjectModal()">‚ûï Nouveau Projet</button>
                <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;" onclick="showImportFolder()">üìÅ Importer Projet</button>
                <input type="file" id="folderInput" webkitdirectory style="display: none;" onchange="importProjectFolder(this.files)">
            </div>
            <div class="projects-list" id="projectsList">
                <!-- Les projets seront ajout√©s ici -->
            </div>
        </div>

        <!-- ZONE CENTRALE -->
        <div class="center-area">
            <!-- TOOLBAR -->
            <div class="toolbar">
                <div class="toolbar-group">
                    <span class="toolbar-label">Projet:</span>
                    <button class="btn btn-primary" onclick="saveProject()" id="saveBtn" disabled>üíæ Sauvegarder</button>
                </div>
                <div class="toolbar-group">
                    <span class="toolbar-label">Fichiers:</span>
                    <input type="file" id="fileInput" accept=".glb,.gltf,.jpg,.jpeg,.png,.mp4" multiple style="display: none;" onchange="handleFileSelect(this.files)">
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">üìÅ Charger</button>
                </div>
                <div class="toolbar-group">
                    <span class="toolbar-label">Mode:</span>
                    <button class="btn btn-secondary" id="translateBtn" onclick="setTransformMode('translate')">üìç Move</button>
                    <button class="btn btn-secondary" id="rotateBtn" onclick="setTransformMode('rotate')">üîÑ Rotate</button>
                    <button class="btn btn-secondary" id="scaleBtn" onclick="setTransformMode('scale')">üìè Scale</button>
                </div>
                <div class="toolbar-group">
                    <button class="btn btn-secondary" onclick="deleteSelected()" id="deleteBtn" disabled>üóëÔ∏è Delete</button>
                    <button class="btn btn-secondary" onclick="centerSelected()" id="centerBtn" disabled>üéØ Center</button>
                </div>
            </div>

            <!-- VIEWPORT 3D -->
            <div class="viewport">
                <div id="canvas-container">
                    <div class="drop-zone" id="dropZone">
                        <div>üìÅ Drop files here</div>
                        <div style="font-size: 12px; margin-top: 10px; color: #aaa;">
                            GLB, JPG, PNG, MP4
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PANNEAU PROPRI√âT√âS -->
        <div class="properties-panel">
            <div class="panel-tabs">
                <button class="panel-tab active" onclick="switchTab('properties')">Properties</button>
                <button class="panel-tab" onclick="switchTab('objects')">Objects</button>
            </div>
            <div class="panel-content">
                <div id="propertiesContent">
                    <h3>Properties</h3>
                    <p style="color: #aaa; text-align: center; margin-top: 50px;">
                        Select an object
                    </p>
                </div>
                <div id="objectsContent" style="display: none;">
                    <h3>Objects</h3>
                    <div class="objects-list" id="objectsList">
                        <p style="color: #aaa; text-align: center; margin-top: 50px;">
                            No objects in scene
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- STATUS BAR -->
    <div class="status-bar">
        <div class="status-item">Objects: <span id="objectCount">0</span></div>
        <div class="status-item">Project: <span id="currentProject">None</span></div>
        <div class="status-item" id="statusMessage">Ready</div>
    </div>

    <!-- MODAL NOUVEAU PROJET -->
    <div class="modal hidden" id="newProjectModal">
        <div class="modal-content">
            <h3>New Project</h3>
            <div class="form-group">
                <label>Name:</label>
                <input type="text" id="projectName" placeholder="My AR Project">
            </div>
            <div class="form-group">
                <label>Description:</label>
                <input type="text" id="projectDescription" placeholder="Project description">
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="hideNewProjectModal()">Cancel</button>
                <button class="btn btn-primary" onclick="createProject()">Create</button>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- JSZip pour cr√©er des archives -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // Variables globales
        let scene, camera, renderer, controls, transformControls;
        let selectedObject = null;
        let objects = [];
        let currentProject = null;
        let projects = JSON.parse(localStorage.getItem('arProjects')) || [];

        // Initialisation
        init();
        loadProjects();
        showLastProjectHint();

        function init() {
            // Sc√®ne
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // Cam√©ra
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Renderer
            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // Contr√¥les orbital
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);

            // Contr√¥les de transformation
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('change', render);
            transformControls.addEventListener('objectChange', function() {
                if (selectedObject) {
                    updatePropertiesPanel(selectedObject);
                }
            });
            transformControls.addEventListener('dragging-changed', function(event) {
                controls.enabled = !event.value;
            });
            scene.add(transformControls);

            // √âclairage am√©lior√©
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Lumi√®re de remplissage
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 3, -5);
            scene.add(fillLight);

            // Grille √©quilibr√©e
            const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0x444444);
            scene.add(gridHelper);

            // Plan de sol invisible pour raycasting
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.name = 'ground';
            scene.add(plane);

            // Gestion des clics
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            // Drag & Drop
            setupDragAndDrop();

            // Boucle de rendu
            animate();
        }

        function onMouseClick(event) {
            // Ignorer si on est en train de manipuler avec les transform controls
            if (transformControls.dragging) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // Filtrer uniquement les objets manipulables (exclure le plan de sol)
            const intersectableObjects = objects.filter(obj => obj.name !== 'ground');
            const intersects = raycaster.intersectObjects(intersectableObjects, true);

            if (intersects.length > 0) {
                // Trouver l'objet parent le plus proche dans notre liste
                let targetObject = intersects[0].object;
                while (targetObject.parent && !objects.includes(targetObject)) {
                    targetObject = targetObject.parent;
                }
                selectObject(targetObject);
            } else {
                selectObject(null);
            }
        }

        function selectObject(obj) {
            selectedObject = obj;
            
            // Mettre √† jour l'√©tat des boutons
            const deleteBtn = document.getElementById('deleteBtn');
            const centerBtn = document.getElementById('centerBtn');
            
            if (obj && obj.name !== 'ground') {
                transformControls.attach(obj);
                updatePropertiesPanel(obj);
                updateStatus(`Selected: ${obj.name || 'Unnamed'}`);
                deleteBtn.disabled = false;
                centerBtn.disabled = false;
            } else {
                transformControls.detach();
                clearPropertiesPanel();
                updateStatus('No selection');
                deleteBtn.disabled = true;
                centerBtn.disabled = true;
            }
        }

        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const container = document.getElementById('canvas-container');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, e => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                container.addEventListener(eventName, () => dropZone.classList.add('active'));
            });

            ['dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, () => dropZone.classList.remove('active'));
            });

            container.addEventListener('drop', e => {
                const files = Array.from(e.dataTransfer.files);
                files.forEach(loadFile);
                
                if (objects.length > 0) {
                    dropZone.classList.add('hidden');
                }
            });
        }

        function loadFile(file) {
            const fileType = file.type;
            const fileName = file.name.toLowerCase();

            if (fileName.endsWith('.glb') || fileName.endsWith('.gltf')) {
                loadGLTF(file);
            } else if (fileType.startsWith('image/')) {
                loadImage(file);
            } else if (fileType.startsWith('video/')) {
                loadVideo(file);
            } else {
                updateStatus(`Unsupported: ${file.name}`);
            }
        }

        function loadGLTF(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const modelData = e.target.result;
                
                const loader = new THREE.GLTFLoader();
                const blob = new Blob([new Uint8Array(e.target.result)], { type: file.type });
                const url = URL.createObjectURL(blob);
                
                loader.load(url, function(gltf) {
                    const model = gltf.scene;
                    model.name = file.name;
                    
                    // Calculer la bo√Æte englobante
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    // Centrer le mod√®le √† l'origine
                    model.position.sub(center);
                    
                    // Redimensionner intelligemment
                    const maxSize = Math.max(size.x, size.y, size.z);
                    let scale = 2;
                    if (maxSize > 0) {
                        scale = Math.min(3, 2 / maxSize); // Limite entre 0.1 et 3
                    }
                    model.scale.setScalar(scale);
                    
                    // Positionner sur la grille (y = 0 pour poser sur le sol)
                    const scaledBox = new THREE.Box3().setFromObject(model);
                    const scaledSize = scaledBox.getSize(new THREE.Vector3());
                    model.position.y = scaledSize.y / 2; // Poser sur le sol
                    
                    // Activer les ombres pour les meshes
                    model.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Stocker les donn√©es pour la sauvegarde
                    model.userData = {
                        type: 'model',
                        fileName: file.name,
                        modelData: modelData,
                        originalBounds: {
                            center: center,
                            size: size,
                            scale: scale
                        }
                    };
                    
                    scene.add(model);
                    objects.push(model);
                    updateObjectCount();
                    updateStatus(`Added: ${file.name}`);
                    
                    // S√©lectionner automatiquement le nouveau mod√®le
                    selectObject(model);
                    
                    // Mettre √† jour la liste d'objets
                    updateObjectsList();
                    
                    // D√©clencher la sauvegarde automatique
                    triggerAutoSave();
                    
                    URL.revokeObjectURL(url);
                }, undefined, function(error) {
                    console.error('Error:', error);
                    updateStatus(`Error: ${file.name}`);
                    URL.revokeObjectURL(url);
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;
                
                const img = document.createElement('img');
                img.onload = function() {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    
                    const aspect = img.naturalWidth / img.naturalHeight;
                    const geometry = new THREE.PlaneGeometry(aspect * 2, 2);
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.name = file.name;
                    plane.position.y = 1; // √âlever au-dessus du sol
                    
                    // Stocker les donn√©es pour la sauvegarde
                    plane.userData = {
                        type: 'image',
                        imageData: imageData,
                        originalSize: {
                            width: img.naturalWidth,
                            height: img.naturalHeight
                        }
                    };
                    
                    scene.add(plane);
                    objects.push(plane);
                    updateObjectCount();
                    updateStatus(`Added: ${file.name}`);
                    
                    // S√©lectionner automatiquement la nouvelle image
                    selectObject(plane);
                    
                    // Mettre √† jour la liste d'objets
                    updateObjectsList();
                    
                    // D√©clencher la sauvegarde automatique
                    triggerAutoSave();
                };
                img.src = imageData;
            };
            reader.readAsDataURL(file);
        }

        function loadVideo(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const videoData = e.target.result;
                
                const video = document.createElement('video');
                video.src = videoData;
                video.loop = true;
                video.muted = true;
                video.crossOrigin = 'anonymous';
                
                video.addEventListener('loadedmetadata', function() {
                    const texture = new THREE.VideoTexture(video);
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.format = THREE.RGBFormat;
                    
                    const aspect = video.videoWidth / video.videoHeight;
                    const geometry = new THREE.PlaneGeometry(aspect * 2, 2);
                    const material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.name = file.name;
                    plane.position.y = 1; // √âlever au-dessus du sol
                    
                    // Stocker les donn√©es pour la sauvegarde
                    plane.userData = {
                        type: 'video',
                        videoData: videoData,
                        originalSize: {
                            width: video.videoWidth,
                            height: video.videoHeight
                        },
                        video: video
                    };
                    
                    scene.add(plane);
                    objects.push(plane);
                    updateObjectCount();
                    console.log('‚úÖ Vid√©o ajout√©e √† la sc√®ne:', objData.name);
                    
                    // Mettre √† jour la liste d'objets
                    updateObjectsList();
                    
                    if (objects.length > 0) {
                        document.getElementById('dropZone').classList.add('hidden');
                    }
                    
                    video.play();
                });
            };
            reader.readAsDataURL(file);
        }

        function setTransformMode(mode) {
            if (!selectedObject) {
                updateStatus('No selection');
                return;
            }
            
            transformControls.setMode(mode);
            updateStatus(`Mode: ${mode}`);
            
            // Mettre √† jour l'apparence des boutons
            document.querySelectorAll('#translateBtn, #rotateBtn, #scaleBtn').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            
            document.getElementById(mode + 'Btn').classList.remove('btn-secondary');
            document.getElementById(mode + 'Btn').classList.add('btn-primary');
        }

        function deleteSelected() {
            if (selectedObject) {
                scene.remove(selectedObject);
                objects = objects.filter(obj => obj !== selectedObject);
                selectObject(null);
                updateObjectCount();
                updateStatus('Deleted');
                
                if (objects.length === 0) {
                    document.getElementById('dropZone').classList.remove('hidden');
                }
                
                // D√©clencher la sauvegarde automatique
                triggerAutoSave();
            }
        }

        function updatePropertiesPanel(obj) {
            const panel = document.getElementById('propertiesContent');
            panel.innerHTML = `
                <div class="property-group">
                    <h4>General</h4>
                    <div class="property-row">
                        <span class="property-label">Name:</span>
                        <input class="property-input" value="${obj.name || 'Unnamed'}" onchange="updateObjectName(this.value)">
                    </div>
                </div>
                
                <div class="property-group">
                    <h4>Position</h4>
                    <div class="property-row">
                        <span class="property-label">X:</span>
                        <input class="property-input" type="number" step="0.1" value="${obj.position.x.toFixed(2)}" onchange="updateObjectPosition('x', this.value)">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Y:</span>
                        <input class="property-input" type="number" step="0.1" value="${obj.position.y.toFixed(2)}" onchange="updateObjectPosition('y', this.value)">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Z:</span>
                        <input class="property-input" type="number" step="0.1" value="${obj.position.z.toFixed(2)}" onchange="updateObjectPosition('z', this.value)">
                    </div>
                </div>
                
                <div class="property-group">
                    <h4>Rotation</h4>
                    <div class="property-row">
                        <span class="property-label">X:</span>
                        <input class="property-input" type="number" step="0.1" value="${(obj.rotation.x * 180 / Math.PI).toFixed(1)}" onchange="updateObjectRotation('x', this.value)">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Y:</span>
                        <input class="property-input" type="number" step="0.1" value="${(obj.rotation.y * 180 / Math.PI).toFixed(1)}" onchange="updateObjectRotation('y', this.value)">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Z:</span>
                        <input class="property-input" type="number" step="0.1" value="${(obj.rotation.z * 180 / Math.PI).toFixed(1)}" onchange="updateObjectRotation('z', this.value)">
                    </div>
                </div>
                
                <div class="property-group">
                    <h4>Scale</h4>
                    <div class="property-row">
                        <span class="property-label">X:</span>
                        <input class="property-input" type="number" step="0.1" value="${obj.scale.x.toFixed(2)}" onchange="updateObjectScale('x', this.value)">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Y:</span>
                        <input class="property-input" type="number" step="0.1" value="${obj.scale.y.toFixed(2)}" onchange="updateObjectScale('y', this.value)">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Z:</span>
                        <input class="property-input" type="number" step="0.1" value="${obj.scale.z.toFixed(2)}" onchange="updateObjectScale('z', this.value)">
                    </div>
                </div>
                
                <button class="delete-btn" onclick="deleteSelected()">üóëÔ∏è Delete</button>
            `;
        }

        function clearPropertiesPanel() {
            document.getElementById('propertiesContent').innerHTML = `
                <p style="color: #aaa; text-align: center; margin-top: 50px;">
                    Select an object
                </p>
            `;
        }

        function updateObjectName(name) {
            if (selectedObject) {
                selectedObject.name = name;
                triggerAutoSave();
            }
        }

        function updateObjectPosition(axis, value) {
            if (selectedObject) {
                selectedObject.position[axis] = parseFloat(value);
                triggerAutoSave();
            }
        }

        function updateObjectRotation(axis, value) {
            if (selectedObject) {
                selectedObject.rotation[axis] = parseFloat(value) * Math.PI / 180;
                triggerAutoSave();
            }
        }

        function updateObjectScale(axis, value) {
            if (selectedObject) {
                selectedObject.scale[axis] = parseFloat(value);
                triggerAutoSave();
            }
        }

        function triggerAutoSave() {
            if (currentProject) {
                // Sauvegarder automatiquement apr√®s un court d√©lai
                if (window.autoSaveTimeout) {
                    clearTimeout(window.autoSaveTimeout);
                }
                
                window.autoSaveTimeout = setTimeout(() => {
                    saveCurrentProject();
                    
                    // Feedback visuel subtil
                    const statusMessage = document.getElementById('statusMessage');
                    const originalText = statusMessage.textContent;
                    statusMessage.textContent = 'üíæ Auto-sauvegard√©';
                    statusMessage.style.color = '#4CAF50';
                    
                    setTimeout(() => {
                        statusMessage.textContent = originalText;
                        statusMessage.style.color = '';
                    }, 1500);
                }, 1000); // D√©lai de 1 seconde
            }
        }

        function updateObjectCount() {
            document.getElementById('objectCount').textContent = objects.length;
        }

        function updateStatus(message) {
            document.getElementById('statusMessage').textContent = message;
        }

        // Gestion des projets
        function showNewProjectModal() {
            console.log('üîç Opening new project modal...');
            const modal = document.getElementById('newProjectModal');
            if (modal) {
                modal.classList.remove('hidden');
                console.log('‚úÖ Modal opened successfully');
                // Focus sur le champ nom pour une meilleure UX
                setTimeout(() => {
                    document.getElementById('projectName').focus();
                }, 100);
            } else {
                console.error('‚ùå Modal element not found!');
            }
        }

        function hideNewProjectModal() {
            document.getElementById('newProjectModal').classList.add('hidden');
            document.getElementById('projectName').value = '';
            document.getElementById('projectDescription').value = '';
        }

        function createProject() {
            const name = document.getElementById('projectName').value.trim();
            const description = document.getElementById('projectDescription').value.trim();
            
            if (!name) {
                alert('Enter project name');
                return;
            }
            
            const project = {
                id: Date.now().toString(),
                name: name,
                description: description,
                created: new Date().toLocaleDateString(),
                scene: {
                    objects: [],
                    camera: {
                        position: { x: 0, y: 5, z: 10 }
                    }
                }
            };
            
            projects.push(project);
            localStorage.setItem('arProjects', JSON.stringify(projects));
            
            loadProjects();
            loadProject(project);
            hideNewProjectModal();
            updateStatus(`Created: ${name}`);
            
            // Activer le bouton de sauvegarde
            document.getElementById('saveBtn').disabled = false;
        }

        function loadProjects() {
            const container = document.getElementById('projectsList');
            container.innerHTML = '';
            
            projects.forEach(project => {
                const item = document.createElement('div');
                item.className = 'project-item';
                item.onclick = () => loadProject(project);
                
                // Ic√¥ne et badge selon le type de projet
                let icon = 'üìÅ';
                let badge = '';
                let titleStyle = '';
                
                if (project.isTemporary) {
                    icon = '‚ö°';
                    badge = `<span style="font-size: 10px; color: #ff9800; font-weight: bold;">(temporaire ${project.sizeMB || ''}MB)</span>`;
                    titleStyle = 'color: #ff9800;';
                } else if (project.imported) {
                    icon = 'üì•';
                    badge = '<span style="font-size: 10px; color: #4CAF50;">(import√©)</span>';
                } else {
                    icon = 'üìÅ';
                }
                
                const date = project.importedAt || project.created;
                
                item.innerHTML = `
                    <h4 style="${titleStyle}">${icon} ${project.name} ${badge}</h4>
                    <p>${project.description || 'Aucune description'}</p>
                    <p style="font-size: 10px; color: #666;">${date}</p>
                    <button class="project-delete-btn" onclick="event.stopPropagation(); deleteProject('${project.id}')" title="Supprimer le projet">√ó</button>
                `;
                
                container.appendChild(item);
            });
        }

        function deleteProject(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project) return;
            
            if (confirm(`√ätes-vous s√ªr de vouloir supprimer le projet "${project.name}" ? Cette action est irr√©versible.`)) {
                // Si c'est le projet actuel, le fermer
                if (currentProject && currentProject.id === projectId) {
                    clearScene();
                    currentProject = null;
                    document.getElementById('currentProject').textContent = 'None';
                    document.getElementById('saveBtn').disabled = true;
                }
                
                // Supprimer le projet de la liste
                projects = projects.filter(p => p.id !== projectId);
                localStorage.setItem('arProjects', JSON.stringify(projects));
                
                // Recharger la liste des projets
                loadProjects();
                updateStatus(`Projet "${project.name}" supprim√©`);
            }
        }

        function showLastProjectHint() {
            // Afficher un message d'aide simple
            if (projects.length > 0) {
                const lastProject = projects[projects.length - 1];
                updateStatus(`üí° Dernier projet: "${lastProject.name}" - Visible dans la liste ci-dessous`);
            } else {
                updateStatus('Cr√©ez votre premier projet avec "‚ûï Nouveau Projet"');
            }
        }

        function loadProject(project) {
            // Sauvegarder le projet actuel avant de changer
            if (currentProject && objects.length > 0) {
                saveCurrentProject();
            }
            
            currentProject = project;
            document.getElementById('currentProject').textContent = project.name;
            
            // Marquer comme actif
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Utiliser une approche plus robuste pour marquer le projet actif
            const projectItems = document.querySelectorAll('.project-item');
            projectItems.forEach(item => {
                if (item.innerHTML.includes(project.name)) {
                    item.classList.add('active');
                }
            });
            
            // Charger la sc√®ne du projet
            clearScene();
            
            // Charger les objets sauvegard√©s avec un d√©lai pour √©viter les conflits
            if (project.scene && project.scene.objects && project.scene.objects.length > 0) {
                updateStatus(`Chargement de ${project.scene.objects.length} objets...`);
                
                // Charger les objets un par un avec un petit d√©lai
                project.scene.objects.forEach((objData, index) => {
                    setTimeout(() => {
                        loadSavedObject(objData);
                        if (index === project.scene.objects.length - 1) {
                            // Tous les objets sont charg√©s
                            updateStatus(`Loaded: ${project.name} (${project.scene.objects.length} objets)`);
                        }
                    }, index * 100); // 100ms de d√©lai entre chaque objet
                });
            } else {
                updateStatus(`Loaded: ${project.name} (projet vide)`);
            }
            
            // Restaurer la position de la cam√©ra si elle existe
            if (project.scene && project.scene.camera) {
                const cam = project.scene.camera;
                if (cam.position) {
                    camera.position.set(cam.position.x, cam.position.y, cam.position.z);
                }
                if (cam.target) {
                    controls.target.set(cam.target.x, cam.target.y, cam.target.z);
                }
                controls.update();
            }
            
            // Activer le bouton de sauvegarde
            document.getElementById('saveBtn').disabled = false;
        }

        function saveCurrentProject() {
            if (!currentProject) return;
            
            currentProject.scene.objects = objects.map(obj => {
                const objData = {
                    name: obj.name || 'Unnamed',
                    type: obj.userData.type || 'unknown',
                    position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
                    rotation: { x: obj.rotation.x, y: obj.rotation.y, z: obj.rotation.z },
                    scale: { x: obj.scale.x, y: obj.scale.y, z: obj.scale.z }
                };
                
                // Sauvegarder les donn√©es sp√©cifiques selon le type
                if (obj.userData.type === 'image') {
                    objData.imageData = obj.userData.imageData;
                    objData.originalSize = obj.userData.originalSize;
                } else if (obj.userData.type === 'video') {
                    objData.videoData = obj.userData.videoData;
                    objData.originalSize = obj.userData.originalSize;
                } else if (obj.userData.type === 'model') {
                    // Pour les mod√®les, on doit g√©rer l'ArrayBuffer diff√©remment
                    objData.fileName = obj.userData.fileName;
                    objData.originalBounds = obj.userData.originalBounds;
                    
                    // Convertir l'ArrayBuffer en Array pour la s√©rialisation JSON
                    if (obj.userData.modelData instanceof ArrayBuffer) {
                        objData.modelData = Array.from(new Uint8Array(obj.userData.modelData));
                    } else {
                        objData.modelData = obj.userData.modelData;
                    }
                }
                
                return objData;
            });
            
            // Sauvegarder la position de la cam√©ra
            currentProject.scene.camera = {
                position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                target: { x: controls.target.x, y: controls.target.y, z: controls.target.z }
            };
            
            // Sauvegarder en localStorage pour les petits projets
            try {
                localStorage.setItem('arProjects', JSON.stringify(projects));
            } catch (error) {
                console.warn('‚ö†Ô∏è LocalStorage plein - utilisez l\'export pour sauvegarder:', error);
            }
        }

        function loadSavedObject(objData) {
            console.log('üîÑ Chargement objet:', objData.type, objData.name);
            
            try {
                if (objData.type === 'image' && objData.imageData) {
                    console.log('üì∑ Chargement image:', objData.name);
                    // Recr√©er l'image √† partir des donn√©es sauvegard√©es
                    const img = document.createElement('img');
                    img.onload = function() {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        
                        const material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: true,
                            side: THREE.DoubleSide
                        });
                        
                        const aspect = objData.originalSize.width / objData.originalSize.height;
                        const geometry = new THREE.PlaneGeometry(aspect * 2, 2);
                        const mesh = new THREE.Mesh(geometry, material);
                        
                        // Restaurer les propri√©t√©s
                        mesh.name = objData.name;
                        mesh.position.set(objData.position.x, objData.position.y, objData.position.z);
                        mesh.rotation.set(objData.rotation.x, objData.rotation.y, objData.rotation.z);
                        mesh.scale.set(objData.scale.x, objData.scale.y, objData.scale.z);
                        
                        mesh.userData = {
                            type: 'image',
                            imageData: objData.imageData,
                            originalSize: objData.originalSize
                        };
                        
                        scene.add(mesh);
                        objects.push(mesh);
                        updateObjectCount();
                        console.log('‚úÖ Image ajout√©e √† la sc√®ne:', objData.name);
                        
                        // Mettre √† jour la liste d'objets
                        updateObjectsList();
                        
                        if (objects.length > 0) {
                            document.getElementById('dropZone').classList.add('hidden');
                        }
                    };
                    img.src = objData.imageData;
                    
                } else if (objData.type === 'video' && objData.videoData) {
                    console.log('üé• Chargement vid√©o:', objData.name);
                    // Recr√©er la vid√©o √† partir des donn√©es sauvegard√©es
                    const video = document.createElement('video');
                    video.src = objData.videoData;
                    video.muted = true;
                    video.loop = true;
                    video.crossOrigin = 'anonymous';
                    
                    const texture = new THREE.VideoTexture(video);
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    
                    const aspect = objData.originalSize.width / objData.originalSize.height;
                    const geometry = new THREE.PlaneGeometry(aspect * 2, 2);
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // Restaurer les propri√©t√©s
                    mesh.name = objData.name;
                    mesh.position.set(objData.position.x, objData.position.y, objData.position.z);
                    mesh.rotation.set(objData.rotation.x, objData.rotation.y, objData.rotation.z);
                    mesh.scale.set(objData.scale.x, objData.scale.y, objData.scale.z);
                    
                    mesh.userData = {
                        type: 'video',
                        videoData: objData.videoData,
                        originalSize: objData.originalSize,
                        video: video
                    };
                    
                    scene.add(mesh);
                    objects.push(mesh);
                    updateObjectCount();
                    console.log('‚úÖ Vid√©o ajout√©e √† la sc√®ne:', objData.name);
                    
                    // Mettre √† jour la liste d'objets
                    updateObjectsList();
                    
                    if (objects.length > 0) {
                        document.getElementById('dropZone').classList.add('hidden');
                    }
                    
                } else if (objData.type === 'model' && objData.modelData) {
                    console.log('üé≤ Chargement mod√®le 3D:', objData.name);
                    console.log('üìä Type de donn√©es:', typeof objData.modelData);
                    console.log('üìä Donn√©es disponibles:', Object.keys(objData));
                    console.log('üìä Est base64:', objData.isBase64);
                    
                    // Recr√©er le mod√®le 3D √† partir des donn√©es sauvegard√©es
                    const loader = new THREE.GLTFLoader();
                    
                    // V√©rifier le format des donn√©es et les convertir si n√©cessaire
                    let arrayBuffer;
                    
                    if (objData.isBase64 && typeof objData.modelData === 'string') {
                        // Donn√©es import√©es depuis un export (base64)
                        console.log('üîÑ Conversion base64 vers ArrayBuffer...');
                        arrayBuffer = base64ToArrayBuffer(objData.modelData);
                        console.log('‚úÖ Conversion termin√©e, taille:', arrayBuffer.byteLength, 'bytes');
                    } else if (objData.modelData instanceof ArrayBuffer) {
                        // Donn√©es d√©j√† en ArrayBuffer (localStorage local)
                        arrayBuffer = objData.modelData;
                    } else if (Array.isArray(objData.modelData)) {
                        // Donn√©es en array (format ancien)
                        arrayBuffer = new Uint8Array(objData.modelData).buffer;
                    } else {
                        console.error('‚ùå Format de donn√©es de mod√®le non reconnu:', typeof objData.modelData);
                        return;
                    }
                    
                    console.log('üìä Taille ArrayBuffer finale:', arrayBuffer.byteLength, 'bytes');
                    
                    const blob = new Blob([arrayBuffer], { type: 'model/gltf-binary' });
                    const url = URL.createObjectURL(blob);
                    
                    loader.load(url, function(gltf) {
                        console.log('‚úÖ Mod√®le 3D charg√© avec succ√®s:', objData.name);
                        const model = gltf.scene;
                        model.name = objData.name;
                        
                        // Restaurer les propri√©t√©s transform√©es
                        model.position.set(objData.position.x, objData.position.y, objData.position.z);
                        model.rotation.set(objData.rotation.x, objData.rotation.y, objData.rotation.z);
                        model.scale.set(objData.scale.x, objData.scale.y, objData.scale.z);
                        
                        console.log('üìç Position restaur√©e:', model.position);
                        console.log('üîÑ Rotation restaur√©e:', model.rotation);
                        console.log('üìè √âchelle restaur√©e:', model.scale);
                        
                        // Activer les ombres pour les meshes
                        model.traverse(function(child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        // Restaurer les userData (garder les donn√©es en ArrayBuffer localement)
                        model.userData = {
                            type: 'model',
                            fileName: objData.fileName || objData.name,
                            modelData: arrayBuffer, // Toujours stocker en ArrayBuffer localement
                            originalBounds: objData.originalBounds
                        };
                        
                        scene.add(model);
                        objects.push(model);
                        updateObjectCount();
                        console.log('‚úÖ Mod√®le 3D ajout√© √† la sc√®ne. Total objets:', objects.length);
                        
                        // Mettre √† jour la liste d'objets
                        updateObjectsList();
                        
                        if (objects.length > 0) {
                            document.getElementById('dropZone').classList.add('hidden');
                        }
                        
                        URL.revokeObjectURL(url);
                        
                    }, undefined, function(error) {
                        console.error('‚ùå Erreur lors du chargement du mod√®le 3D:', error);
                        console.error('‚ùå URL blob:', url);
                        console.error('‚ùå Taille des donn√©es:', arrayBuffer.byteLength);
                        updateStatus(`Erreur de chargement: ${objData.name}`);
                        URL.revokeObjectURL(url);
                    });
                } else {
                    console.warn('‚ö†Ô∏è Type d\'objet non support√© ou donn√©es manquantes:', objData.type, objData.name);
                }
                
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement de l\'objet:', error);
                updateStatus(`Erreur de chargement: ${objData.name}`);
            }
        }

        function clearScene() {
            objects.forEach(obj => scene.remove(obj));
            objects = [];
            selectObject(null);
            updateObjectCount();
            updateObjectsList();
            document.getElementById('dropZone').classList.remove('hidden');
        }

        function saveProject() {
            if (!currentProject) {
                updateStatus('No project');
                return;
            }
            
            saveCurrentProject();
            updateStatus('‚úÖ Projet sauvegard√©');
            
            // Animation visuelle pour indiquer la sauvegarde
            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.innerHTML;
            saveBtn.innerHTML = '‚úÖ Sauvegard√©';
            saveBtn.style.backgroundColor = '#4CAF50';
            
            setTimeout(() => {
                saveBtn.innerHTML = originalText;
                saveBtn.style.backgroundColor = '';
            }, 2000);
        }

        function exportProject() {
            if (!currentProject) {
                updateStatus('No project to export');
                return;
            }
            
            // Sauvegarder d'abord le projet actuel
            saveCurrentProject();
            
            // Cr√©er un nom de fichier avec la date
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
            const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
            const fileName = `${currentProject.name}_${dateStr}_${timeStr}.json`;
            
            // Ajouter des m√©tadonn√©es utiles (sans conversion base64 pour l'instant)
            const exportData = {
                ...currentProject,
                exportInfo: {
                    exportedAt: now.toISOString(),
                    version: '2.2',
                    objectCount: objects.length,
                    note: 'Metadata only - use ZIP export for full data'
                }
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = fileName;
            link.click();
            
            // Nettoyer
            setTimeout(() => URL.revokeObjectURL(link.href), 100);
            
            const fileSizeKB = (dataStr.length / 1024).toFixed(1);
            updateStatus(`‚úÖ Exported metadata: ${fileName} (${fileSizeKB}KB)`);
        }
        
        // Fonction utilitaire pour convertir ArrayBuffer en base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        
        // Fonction utilitaire pour convertir base64 en ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function previewAR() {
            if (!currentProject || objects.length === 0) {
                updateStatus('Nothing to preview');
                return;
            }
            
            saveProject();
            updateStatus('Opening AR...');
            
            // TODO: G√©n√©rer et ouvrir la version AR
            window.open('index.html', '_blank');
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        // Nouvelle fonction pour g√©rer la s√©lection de fichiers via le bouton
        function handleFileSelect(files) {
            Array.from(files).forEach(loadFile);
            
            if (objects.length > 0) {
                document.getElementById('dropZone').classList.add('hidden');
            }
        }

        function centerSelected() {
            if (selectedObject) {
                // Centrer l'objet √† l'origine (0, 0, 0) mais garder Y pour qu'il reste sur le sol
                const box = new THREE.Box3().setFromObject(selectedObject);
                const size = box.getSize(new THREE.Vector3());
                
                selectedObject.position.x = 0;
                selectedObject.position.z = 0;
                selectedObject.position.y = size.y / 2; // Poser sur le sol
                
                updatePropertiesPanel(selectedObject);
                updateStatus('Centered');
            }
        }

        function createDemoProject() {
            const demoProject = {
                id: 'demo-' + Date.now().toString(),
                name: 'üåª Projet D√©mo - Fleurs',
                description: 'Projet d\'exemple avec une image de fleurs',
                created: new Date().toLocaleDateString(),
                scene: {
                    objects: [],
                    camera: {
                        position: { x: 0, y: 5, z: 10 }
                    }
                }
            };
            
            projects.push(demoProject);
            localStorage.setItem('arProjects', JSON.stringify(projects));
            
            loadProjects();
            loadProject(demoProject);
            updateStatus('Projet d√©mo cr√©√© - Chargez une image depuis assets/');
            
            // Activer le bouton de sauvegarde
            document.getElementById('saveBtn').disabled = false;
        }

        function showImportFolder() {
            // Mettre √† jour le status pour indiquer que c'est l'action principale
            updateStatus('üóÇÔ∏è S√©lectionnez le dossier de votre projet d√©compress√©...');
            document.getElementById('folderInput').click();
        }

        function importProjectFolder(files) {
            if (!files || files.length === 0) return;
            
            updateStatus('üîÑ Reading project folder...');
            console.log('üìÅ Folder selected with', files.length, 'files');
            
            // Convertir FileList en Map pour un acc√®s facile
            const fileMap = new Map();
            for (const file of files) {
                fileMap.set(file.webkitRelativePath, file);
            }
            
            // Chercher project.json √† la racine
            const projectJsonFile = fileMap.get('project.json') || 
                                   Array.from(fileMap.keys()).find(path => path.endsWith('/project.json'));
            
            if (!projectJsonFile) {
                alert('‚ùå project.json not found in folder');
                updateStatus('Import failed - project.json missing');
                return;
            }
            
            console.log('üìÑ Found project.json:', projectJsonFile);
            
            // Lire project.json
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    console.log('üìä Project data loaded:', projectData.name);
                    
                    // Cr√©er un nouveau projet import√©
                    const importedProject = {
                        ...projectData,
                        id: 'imported-folder-' + Date.now().toString(),
                        imported: true,
                        importedAt: new Date().toLocaleDateString()
                    };
                    
                    // Traiter chaque objet et charger ses assets
                    const promises = [];
                    
                    if (importedProject.scene && importedProject.scene.objects) {
                        importedProject.scene.objects.forEach((objData, index) => {
                            if (objData.assetPath) {
                                // Chercher le fichier asset correspondant
                                const assetFile = fileMap.get(objData.assetPath) || 
                                                 Array.from(fileMap.keys()).find(path => path.endsWith(objData.assetPath));
                                
                                if (assetFile) {
                                    console.log(`üîç Found asset: ${objData.assetPath}`);
                                    
                                    if (objData.type === 'model') {
                                        const promise = new Promise(resolve => {
                                            const reader = new FileReader();
                                            reader.onload = e => {
                                                objData.modelData = Array.from(new Uint8Array(e.target.result));
                                                objData.fileName = objData.fileName || assetFile.split('/').pop();
                                                console.log(`‚úÖ Loaded model: ${objData.assetPath}`);
                                                resolve();
                                            };
                                            reader.readAsArrayBuffer(fileMap.get(assetFile));
                                        });
                                        promises.push(promise);
                                        
                                    } else if (objData.type === 'image') {
                                        const promise = new Promise(resolve => {
                                            const reader = new FileReader();
                                            reader.onload = e => {
                                                objData.imageData = e.target.result;
                                                console.log(`‚úÖ Loaded image: ${objData.assetPath}`);
                                                resolve();
                                            };
                                            reader.readAsDataURL(fileMap.get(assetFile));
                                        });
                                        promises.push(promise);
                                        
                                    } else if (objData.type === 'video') {
                                        const promise = new Promise(resolve => {
                                            const reader = new FileReader();
                                            reader.onload = e => {
                                                objData.videoData = e.target.result;
                                                console.log(`‚úÖ Loaded video: ${objData.assetPath}`);
                                                resolve();
                                            };
                                            reader.readAsDataURL(fileMap.get(assetFile));
                                        });
                                        promises.push(promise);
                                    }
                                } else {
                                    console.warn(`‚ö†Ô∏è Asset not found: ${objData.assetPath}`);
                                }
                            }
                        });
                    }
                    
                    // Attendre que tous les assets soient charg√©s
                    Promise.all(promises)
                        .then(() => {
                            // Calculer la taille approximative du projet
                            let estimatedSizeMB = 0;
                            if (importedProject.scene && importedProject.scene.objects) {
                                importedProject.scene.objects.forEach(objData => {
                                    if (objData.modelData && Array.isArray(objData.modelData)) {
                                        estimatedSizeMB += objData.modelData.length / (1024 * 1024);
                                    }
                                });
                            }
                            
                            console.log(`üìä Estimated project size: ${estimatedSizeMB.toFixed(1)}MB`);
                            
                            // Marquer le projet selon sa taille
                            if (estimatedSizeMB >= 5) {
                                importedProject.isTemporary = true;
                                importedProject.sizeMB = estimatedSizeMB.toFixed(1);
                            }
                            
                            // Toujours ajouter le projet √† la liste pour l'affichage
                            projects.push(importedProject);
                            
                            // Ne sauvegarder dans localStorage que si le projet est assez petit
                            if (estimatedSizeMB < 5) {
                                try {
                                    localStorage.setItem('arProjects', JSON.stringify(projects));
                                    console.log('‚úÖ Project saved to localStorage');
                                } catch (error) {
                                    console.warn('‚ö†Ô∏è Failed to save to localStorage:', error);
                                    // En cas d'erreur, marquer comme temporaire mais garder dans la liste
                                    importedProject.isTemporary = true;
                                }
                            } else {
                                console.log('‚ö†Ô∏è Project too large for localStorage, displaying as temporary');
                            }
                            
                            // Charger le projet directement
                            currentProject = importedProject;
                            document.getElementById('currentProject').textContent = importedProject.name;
                            
                            // Charger la sc√®ne
                            clearScene();
                            
                            // Charger les objets
                            if (importedProject.scene && importedProject.scene.objects) {
                                importedProject.scene.objects.forEach((objData, index) => {
                                    setTimeout(() => {
                                        loadSavedObject(objData);
                                    }, index * 100);
                                });
                            }
                            
                            // Recharger la liste des projets
                            loadProjects();
                            
                            const objectCount = importedProject.scene?.objects?.length || 0;
                            if (estimatedSizeMB >= 5) {
                                updateStatus(`‚úÖ Folder imported: ${projectData.name} (${objectCount} objects) - Too large for localStorage`);
                            } else {
                                updateStatus(`‚úÖ Folder imported: ${projectData.name} (${objectCount} objects)`);
                            }
                            
                            // Activer le bouton de sauvegarde
                            document.getElementById('saveBtn').disabled = false;
                        })
                        .catch(error => {
                            console.error('Error loading assets:', error);
                            updateStatus('‚ùå Error loading project assets');
                        });
                        
                } catch (error) {
                    console.error('Error parsing project.json:', error);
                    alert('‚ùå Invalid project.json file');
                    updateStatus('Import failed - invalid JSON');
                }
            };
            
            const projectFile = fileMap.get(projectJsonFile);
            reader.readAsText(projectFile);
        }

        function switchTab(tab) {
            const propertiesContent = document.getElementById('propertiesContent');
            const objectsContent = document.getElementById('objectsContent');
            const tabs = document.querySelectorAll('.panel-tab');
            
            // Mettre √† jour l'affichage
            if (tab === 'properties') {
                propertiesContent.style.display = 'block';
                objectsContent.style.display = 'none';
                tabs[0].classList.add('active');
                tabs[1].classList.remove('active');
            } else if (tab === 'objects') {
                propertiesContent.style.display = 'none';
                objectsContent.style.display = 'block';
                tabs[0].classList.remove('active');
                tabs[1].classList.add('active');
                updateObjectsList();
            }
        }

        function updateObjectsList() {
            const container = document.getElementById('objectsList');
            
            if (objects.length === 0) {
                container.innerHTML = '<p style="color: #aaa; text-align: center; margin-top: 50px;">No objects in scene</p>';
                return;
            }
            
            container.innerHTML = '';
            
            objects.forEach((obj, index) => {
                const item = document.createElement('div');
                item.className = 'object-item';
                if (obj === selectedObject) {
                    item.classList.add('selected');
                }
                
                // Ic√¥ne selon le type
                let icon = 'üìÑ';
                if (obj.userData.type === 'model') icon = 'üé≤';
                else if (obj.userData.type === 'image') icon = 'üñºÔ∏è';
                else if (obj.userData.type === 'video') icon = 'üé•';
                
                item.innerHTML = `
                    <div class="object-info" onclick="selectObjectFromList(${index})">
                        <div class="object-name">${icon} ${obj.name || 'Unnamed'}</div>
                        <div class="object-type">${obj.userData.type || 'unknown'}</div>
                    </div>
                    <div class="object-actions">
                        <button class="object-rename-btn" onclick="renameObject(${index})" title="Rename">‚úèÔ∏è</button>
                        <button class="object-delete-btn" onclick="deleteObjectFromList(${index})" title="Delete">üóëÔ∏è</button>
                    </div>
                `;
                
                container.appendChild(item);
            });
        }

        function selectObjectFromList(index) {
            if (index >= 0 && index < objects.length) {
                const obj = objects[index];
                selectObject(obj);
                updateObjectsList(); // Mettre √† jour la s√©lection visuelle
                
                // Passer automatiquement √† l'onglet Properties
                switchTab('properties');
            }
        }

        function renameObject(index) {
            if (index >= 0 && index < objects.length) {
                const obj = objects[index];
                const newName = prompt('New name:', obj.name || 'Unnamed');
                if (newName && newName.trim()) {
                    obj.name = newName.trim();
                    updateObjectsList();
                    if (obj === selectedObject) {
                        updatePropertiesPanel(obj);
                    }
                    triggerAutoSave();
                }
            }
        }

        function deleteObjectFromList(index) {
            if (index >= 0 && index < objects.length) {
                const obj = objects[index];
                if (confirm(`Delete "${obj.name || 'Unnamed'}" ?`)) {
                    scene.remove(obj);
                    objects.splice(index, 1);
                    
                    if (obj === selectedObject) {
                        selectObject(null);
                    }
                    
                    updateObjectCount();
                    updateObjectsList();
                    updateStatus('Object deleted');
                    
                    if (objects.length === 0) {
                        document.getElementById('dropZone').classList.remove('hidden');
                    }
                    
                    triggerAutoSave();
                }
            }
        }

        function showImportZIP() {
            document.getElementById('zipFileInput').click();
        }

        function importProjectZIP(file) {
            if (!file) return;
            
            updateStatus('üîÑ Reading ZIP file...');
            
            JSZip.loadAsync(file)
                .then(function(zip) {
                    console.log('üì¶ ZIP loaded successfully');
                    
                    // V√©rifier que project.json existe
                    if (!zip.files['project.json']) {
                        alert('‚ùå Invalid ZIP: project.json not found');
                        updateStatus('Import failed - invalid ZIP');
                        return;
                    }
                    
                    // Lire project.json
                    zip.files['project.json'].async('string')
                        .then(function(projectJsonStr) {
                            const projectData = JSON.parse(projectJsonStr);
                            
                            // Cr√©er un nouveau projet import√©
                            const importedProject = {
                                ...projectData,
                                id: 'imported-zip-' + Date.now().toString(),
                                imported: true,
                                importedAt: new Date().toLocaleDateString()
                            };
                            
                            // Traiter chaque objet et charger ses assets
                            const promises = [];
                            
                            if (importedProject.scene && importedProject.scene.objects) {
                                importedProject.scene.objects.forEach((objData, index) => {
                                    if (objData.type === 'model' && objData.assetPath) {
                                        const promise = zip.files[objData.assetPath].async('arraybuffer')
                                            .then(buffer => {
                                                objData.modelData = Array.from(new Uint8Array(buffer));
                                                console.log(`‚úÖ Loaded model data: ${objData.assetPath}`);
                                            });
                                        promises.push(promise);
                                        
                                    } else if (objData.type === 'image' && objData.assetPath) {
                                        const promise = zip.files[objData.assetPath].async('blob')
                                            .then(blob => {
                                                return new Promise(resolve => {
                                                    const reader = new FileReader();
                                                    reader.onload = e => {
                                                        objData.imageData = e.target.result;
                                                        console.log(`‚úÖ Loaded image data: ${objData.assetPath}`);
                                                        resolve();
                                                    };
                                                    reader.readAsDataURL(blob);
                                                });
                                            });
                                        promises.push(promise);
                                        
                                    } else if (objData.type === 'video' && objData.assetPath) {
                                        const promise = zip.files[objData.assetPath].async('blob')
                                            .then(blob => {
                                                return new Promise(resolve => {
                                                    const reader = new FileReader();
                                                    reader.onload = e => {
                                                        objData.videoData = e.target.result;
                                                        console.log(`‚úÖ Loaded video data: ${objData.assetPath}`);
                                                        resolve();
                                                    };
                                                    reader.readAsDataURL(blob);
                                                });
                                            });
                                        promises.push(promise);
                                    }
                                });
                            }
                            
                            // Attendre que tous les assets soient charg√©s
                            Promise.all(promises)
                                .then(() => {
                                    // Ajouter aux projets locaux
                                    projects.push(importedProject);
                                    localStorage.setItem('arProjects', JSON.stringify(projects));
                                    
                                    // Recharger la liste et charger le projet import√©
                                    loadProjects();
                                    loadProject(importedProject);
                                    
                                    const objectCount = importedProject.scene?.objects?.length || 0;
                                    updateStatus(`‚úÖ ZIP imported: ${projectData.name} (${objectCount} objects)`);
                                })
                                .catch(error => {
                                    console.error('Error loading assets:', error);
                                    updateStatus('‚ùå Error loading project assets');
                                });
                        })
                        .catch(error => {
                            console.error('Error reading project.json:', error);
                            updateStatus('‚ùå Error reading project data');
                        });
                })
                .catch(function(error) {
                    console.error('Error loading ZIP:', error);
                    alert('‚ùå Error loading ZIP file');
                    updateStatus('Import failed - ZIP error');
                });
        }

        function exportProjectZIP() {
            if (!currentProject) {
                updateStatus('No project to export');
                return;
            }
            
            if (objects.length === 0) {
                updateStatus('No objects to export');
                return;
            }
            
            // Sauvegarder d'abord le projet actuel
            saveCurrentProject();
            updateStatus('üîÑ Creating ZIP archive...');
            
            const zip = new JSZip();
            const assetsFolder = zip.folder("assets");
            
            // Cr√©er le projet.json sans les donn√©es binaires
            const projectData = {
                ...currentProject,
                exportInfo: {
                    exportedAt: new Date().toISOString(),
                    version: '3.0',
                    objectCount: objects.length,
                    format: 'ZIP with separate files'
                }
            };
            
            // Modifier les objets pour r√©f√©rencer les fichiers externes
            if (projectData.scene && projectData.scene.objects) {
                projectData.scene.objects = projectData.scene.objects.map(objData => {
                    const cleanObjData = {
                        name: objData.name,
                        type: objData.type,
                        position: objData.position,
                        rotation: objData.rotation,
                        scale: objData.scale
                    };
                    
                    if (objData.type === 'model') {
                        cleanObjData.fileName = objData.fileName;
                        cleanObjData.originalBounds = objData.originalBounds;
                        cleanObjData.assetPath = `assets/${objData.fileName}`;
                    } else if (objData.type === 'image') {
                        cleanObjData.originalSize = objData.originalSize;
                        cleanObjData.assetPath = `assets/${objData.name}`;
                    } else if (objData.type === 'video') {
                        cleanObjData.originalSize = objData.originalSize;
                        cleanObjData.assetPath = `assets/${objData.name}`;
                    }
                    
                    return cleanObjData;
                });
            }
            
            // Ajouter le project.json au ZIP
            zip.file("project.json", JSON.stringify(projectData, null, 2));
            
            // Traiter chaque objet et ajouter ses fichiers
            const processObject = (obj, index) => {
                return new Promise((resolve) => {
                    if (obj.userData.type === 'model' && obj.userData.modelData) {
                        // Ajouter le fichier GLB
                        const fileName = obj.userData.fileName || `model_${index}.glb`;
                        
                        if (obj.userData.modelData instanceof ArrayBuffer) {
                            assetsFolder.file(fileName, obj.userData.modelData);
                        } else if (Array.isArray(obj.userData.modelData)) {
                            const buffer = new Uint8Array(obj.userData.modelData).buffer;
                            assetsFolder.file(fileName, buffer);
                        }
                        
                        console.log(`‚úÖ Added model: ${fileName}`);
                        
                    } else if (obj.userData.type === 'image' && obj.userData.imageData) {
                        // Convertir les donn√©es image en blob
                        fetch(obj.userData.imageData)
                            .then(res => res.blob())
                            .then(blob => {
                                const fileName = obj.name || `image_${index}.jpg`;
                                assetsFolder.file(fileName, blob);
                                console.log(`‚úÖ Added image: ${fileName}`);
                                resolve();
                            });
                        return;
                        
                    } else if (obj.userData.type === 'video' && obj.userData.videoData) {
                        // Convertir les donn√©es vid√©o en blob
                        fetch(obj.userData.videoData)
                            .then(res => res.blob())
                            .then(blob => {
                                const fileName = obj.name || `video_${index}.mp4`;
                                assetsFolder.file(fileName, blob);
                                console.log(`‚úÖ Added video: ${fileName}`);
                                resolve();
                            });
                        return;
                    }
                    
                    resolve();
                });
            };
            
            // Traiter tous les objets
            Promise.all(objects.map((obj, index) => processObject(obj, index)))
                .then(() => {
                    // G√©n√©rer le ZIP
                    updateStatus('üîÑ Generating ZIP file...');
                    
                    zip.generateAsync({ type: "blob" })
                        .then(function(content) {
                            // T√©l√©charger le fichier ZIP
                            const now = new Date();
                            const dateStr = now.toISOString().split('T')[0];
                            const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
                            const fileName = `${currentProject.name}_${dateStr}_${timeStr}.zip`;
                            
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(content);
                            link.download = fileName;
                            link.click();
                            
                            setTimeout(() => URL.revokeObjectURL(link.href), 100);
                            
                            const fileSizeMB = (content.size / 1024 / 1024).toFixed(2);
                            updateStatus(`‚úÖ Downloaded: ${fileName} (${fileSizeMB}MB)`);
                        });
                })
                .catch(error => {
                    console.error('Error creating ZIP:', error);
                    updateStatus('‚ùå Error creating ZIP file');
                });
        }
    </script>
</body>
</html> 